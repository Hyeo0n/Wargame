<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h1> Dreamhack "uncommon e"  Write-UP</h1>
</body>
<br>
<br>
</html>

2025.10.28 풀이

<img width="602" height="610" alt="image" src="https://github.com/user-attachments/assets/0b3dc20f-6e19-4a3c-ad43-a5004f2c3df9" />

다음 문제를 풀이해보도록 하겠다.
<br>


<img width="1514" height="1234" alt="image" src="https://github.com/user-attachments/assets/8ccf3d80-285e-47a5-b4bd-90a8ff0e0cd1" />

<img width="2880" height="1006" alt="image" src="https://github.com/user-attachments/assets/5581fc77-7c74-48fc-be42-4e3ab0acb0fb" />

문제 파일은 다음과 같다.
위의 prob.py 파일 코드를 살펴보면, 같은 N으로 암호화되어 있고, 다른 지수 e1, e2가 있고, 같은 평문 m을 사용한다.
그리고 문제의 파일이 uncommon이라는 것을 이용하여, 이 것이 common modulud attack 공격법과 관련된 것을 알아낼 수 있었다.
이는 RSA의 수학적 성질에서 비롯되는데, 같은 N, 서로 다른 ​e1, e2, 같은 평문 m, 그리고 gcd(e1, e2)=1 인 조건을 이용하면 된다고 한다. 
이 조건을 가지고 ae1 + be2 = 1 이 되는 a,b를 찾아야 하는데, 이는 확장 유클리드 알고리즘을 가지고 구하면 된다. 
```
FLAG_enc1 = FLAG^e1 mod N
FLAG_enc2 = FLAG^e2 mod N
```
이 공식을 활용하여 문제를 풀이하면 될 것으로 보인다.
<br>


```
N = 18564839028340970630632687927085732690660216946716888067188954046812800985732372062460700863888002343155902759133649880101140768419725781550847529242612574780286876355781415545270149267924318930484262298628091098398893193544538272524290190578306149953368594658823348775434109820836311754081667945186523509419274141640792179302149121645060758381445210342226062749581257840649008843072969882069745488933714383742625035916351887508696280553528500528993974650390749489910938646668966427281419193682964555099697539229141704274820381967489671915008271272572784624353477273387243166242973237904102218303978989538340075110803
e1 = 26107
e2 = 416
c1 = 7527079488835824550176589432384780921138078216741164078317178088512020484637815911814449926944662371885728405467621509470317993615175662631245614263206465411761405248665475018014955011387536383732578999002193581953127201730485926821982569309896641811322758517611730555795173063573946211306084429097792646498732335587337634527626172754334153175582669944053431474970826408358022316126279869698898223075336790046723458233152991869045783807109865365096509043487724858636091575421769914060998644878330883643511254289263960487281213979614256506109469224245020612145584918823245558025971100167133602718304130194072814312710
c2 = 5553467916392779302319650321161682360291392077019602231908379041584499902773710723619110301005008094731504431902945888409491392723061165695579512443486392024940348967751410819758344508288749930005375895909393752897849038447778016747963886132791102187462287312608282729773341145901349954559564077909026595969034706754208713806020071917600988186991043342705750598606533751031166628502148837344385933277599437539183985932955644653119376571815604213229278422645273875273059325957488817516922134037588666169092554553063254879269416996367056713107865228810125004163068707218820011235988174311427569510212386257879728088984

# 확장 유클리드: a*e1 + b*e2 = 1
def egcd(a,b):
    if b == 0:
        return (a, 1, 0)
    g, x, y = egcd(b, a % b)
    return (g, y, x - (a//b)*y)

g, a, b = egcd(e1, e2)
assert g == 1

m = (pow(c1, a, N) * pow(c2, b, N)) % N

# 바이트로 변환
msg = m.to_bytes((m.bit_length()+7)//8, 'big')
print(msg)
```

유클리드 알고리즘을 활용하여, 다음과 같은 스크립트를 작성해보았다.
이를 실행시켜 보면,
<br>


<img width="1392" height="112" alt="image" src="https://github.com/user-attachments/assets/a584d3bd-31bb-4193-a0ea-92cb8bcaae6e" />

다음과 같이 플래그를 구할 수 있다.
<br>


```
DH{7e532757ebddde149f45c32156e58421e95b5c691b668f1681677af9495f7e36}
```

